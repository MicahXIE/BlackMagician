1. Dictionaries are unordered in Python. If you do care about the order of the entries, starting with Python 2.7 you can use collections.OrderedDict.

2. Construct OrderedCounter

from collections import OrderedDict, Counter

class OrderedCounter(Counter, OrderedDict):
    pass

3. sorted list based on second value then first value
d = [('B', 3), ('A', 2), ('A', 1), ('I', 1), ('J', 1)]
sorted(d,key=lambda x:(-x[1],x[0]))
Since your "values" are numeric, you can easily reverse the sort order by changing the sign.

If your values can't so easily be "negated" to put big items first, an easy work-around is to sort twice:

from operator import itemgetter
d.sort(key=itemgetter(0))
d.sort(key=itemgetter(1),reverse=True)
which works because python's sorting is stable.

4. sum & len
>>>sum([0,1,2])  
3  
>>> sum((2, 3, 4), 1)        # 元组计算总和后再加 1
10
>>> sum([0,1,2,3,4], 2)      # 列表计算总和后再加 2
12

Python len() 方法返回对象（字符、列表、元组等）长度或项目个数。
>>>str = "runoob"
>>> len(str)             # 字符串长度
6
>>> l = [1,2,3,4,5]
>>> len(l)               # 列表元素个数
5

5. map
>>> arr = map(int,input().split())
1 2 3
>>> type(arr)
<class 'map'>



6. * and ** usage:
The single star * unpacks the sequence/collection into positional arguments, so you can do this:

def sum(a, b):
    return a + b

values = (1, 2)

s = sum(*values)
This will unpack the tuple so that it actually executes as:

s = sum(1, 2)
The double star ** does the same, only using a dictionary and thus named arguments:

values = { 'a': 1, 'b': 2 }
s = sum(**values)
You can also combine:

def sum(a, b, c, d):
    return a + b + c + d

values1 = (1, 2)
values2 = { 'c': 10, 'd': 15 } # must 'c' and 'd' same as sum paras
s = sum(*values1, **values2)
will execute as:

s = sum(1, 2, c=10, d=15)


7. https://www.hackerrank.com/challenges/symmetric-difference/problem
very good example for introduction the functions of set

https://www.programiz.com/python-programming/methods/built-in/sorted
set sorted reference

set s size: len(s)

https://www.hackerrank.com/challenges/py-set-discard-remove-pop/problem?h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen
set remove and discard difference

set a, b union:
a.union(b) or a|b

set a, b intersection:
a.intersection(b) or a&b

set a, b difference:
a.difference(b) or a - set(b)

set a, b symmetric difference:
a.symmetric_difference(b) or a^set(b)

extend:
.update() |=
.intersection_update() &=
.difference_update() -=
.symmetric_difference_update() ^=

8. enumerate, yield





9. Counter example pls refer to example The_Captain_Room.py

c = Counter(lst)

for k,v in c.items():
    if v == 1:
        print(k)


10. issuperset and issubset
pls refer to Check_Strict_Superset.py file


11. math pow

print(a**b)
print(a**b%m)
#print(pow(a,b))
#print(pow(a,b,m))


12. Integers
Integers in Python can be as big as the bytes in your machine's memory. There is no limit in size as there is: 2^31-1 (c++ int) or 2^63-1 (C++ long long int).



13. itertools combinations and combinations_with_replacement


>>> A = [1,1,3,3,3]
>>> print list(combinations(A,2))
[(1, 1), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (3, 3), (3, 3), (3, 3)]


14. Built-in functions

Zipped:
>>> print zip([1,2,3,4,5,6],'Hacker')
[(1, 'H'), (2, 'a'), (3, 'c'), (4, 'k'), (5, 'e'), (6, 'r')]
>>> 
>>> print zip([1,2,3,4,5,6],[0,9,8,7,6,5,4,3,2,1])
[(1, 0), (2, 9), (3, 8), (4, 7), (5, 6), (6, 5)]

two-dimensional array sort:
1)
sorted(li,key=lambda l:l[1], reverse=True)
[[2, 0.39], [4, 0.31], [5, 0.27], [1, 0.23]]
2)
from operator import itemgetter
outputlist = sorted(inputlist, key=itemgetter(1), reverse=True)


Any or All:
>>> any([1>0,1==0,1<0])
True
>>> all(['a'<'b','b'<'c'])
True

palindromic integer 回文的整数

>>> s = 'abc'
>>> sorted(s)
['a', 'b', 'c']
>>> 
after sorted, string change to list


15. map and split()

>>> mp = map(int, input().strip().split())
1 2 3
>>> mp
<map object at 0x105ea6198>

>>> sp = input().strip().split()
1 2 3
>>> sp
['1', '2', '3']
>>> type(sp)
<class 'list'>


16. map, reduce, filter

>> print (list(map(len, ['Tina', 'Raj', 'Tom'])))  
[4, 3, 3] 

>> sum = lambda a, b, c: a + b + c
>> sum(1, 2, 3)
6


>>> l = list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> l = list(map(lambda x:x*x, l))
>>> l
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> l = list(filter(lambda x: x > 10 and x < 80, l))
>>> l
[16, 25, 36, 49, 64]
>>> 


The reduce() function applies a function of two arguments cumulatively on a list of objects in succession from left to right to reduce it to one value. Say you have a list, say [1,2,3] and you have to find its sum.

>>> reduce(lambda x, y : x + y,[1,2,3])
6
You can also define an initial value. If it is specified, the function will assume initial value as the value given, and then reduce. It is equivalent to adding the initial value at the beginning of the list. For example:

>>> reduce(lambda x, y : x + y, [1,2,3], -3)
3


Python Fraction:
from fractions import Fraction

>>> Fraction(5, 16) - Fraction(1, 4)
Fraction(1, 16)
>>> Fraction(1, 16) * Fraction(3, 16)
Fraction(3, 256)
>>> Fraction(3, 16) / Fraction(1, 8)
Fraction(3, 2)

reference: http://python.jobbole.com/81213/



17. re.compile, re.match and re.search



18. Numpy and Pandas

The NumPy (Numeric Python) package helps us manipulate large arrays and matrices of numeric data.

1)Arrays

A NumPy array is a grid of values. They are similar to lists, except that every element of an array must be the same type.

import numpy

a = numpy.array([1,2,3,4,5])
print a[1]          #2

b = numpy.array([1,2,3,4,5],float)
print b[1]          #2.0

In the above example, numpy.array() is used to convert a list into a NumPy array. The second argument (float) can be used to set the type of array elements.

e.g
arr = numpy.array(arr[::-1],float)

2) shape and reshape
e.g
1 2 3 4 5 6 7 8 9

=>
[[1 2 3]
 [4 5 6]
 [7 8 9]]


lst = list(map(int, input().strip().split()))
array = numpy.array(lst)
#wont change array by using reshape
#print(numpy.reshape(array,(3,3)))
array.shape = (3,3)
print(array)

3) Transpose and Flatten
import numpy

my_array = numpy.array([[1,2,3],
                        [4,5,6]])

print numpy.transpose(my_array)

#Output
[[1 4]
 [2 5]
 [3 6]]

print my_array.flatten()

#Output
[1 2 3 4 5 6]

4) concatenate

e.g

import numpy

array_1 = numpy.array([[1,2,3],[0,0,0]])
array_2 = numpy.array([[0,0,0],[7,8,9]])

print numpy.concatenate((array_1, array_2), axis = 1)   

#Output
[[1 2 3 0 0 0]
 [0 0 0 7 8 9]]


5) zeros and ones
import numpy

print numpy.zeros((1,2))                    #Default type is float
#Output : [[ 0.  0.]] 

print numpy.zeros((1,2), dtype = numpy.int) #Type changes to int
#Output : [[0 0]]


print numpy.ones((1,2))                    #Default type is float
#Output : [[ 1.  1.]] 

print numpy.ones((1,2), dtype = numpy.int) #Type changes to int
#Output : [[1 1]]   


6) Eye and Identity
import numpy
print numpy.identity(3) #3 is for  dimension 3 X 3

#Output
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]


print numpy.eye(8, 7, k = 1)    # 8 X 7 Dimensional array with first upper diagonal 1.

#Output
[[ 0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.]
 [ 0.  0.  0.  0.  0.  0.  1.]
 [ 0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.]]


print numpy.eye(8, 7, k = -2)   # 8 X 7 Dimensional array with second lower diagonal 1.



7) Mathematics

e.g

print(*[eval('a1'+i+'a2') for i in ['+','-','*','//','%','**']], sep='\n')

#print([a1+a2])
#=>[array([[ 6,  8, 10, 12]])]

#print(*[a1+a2])
#=>[[ 6  8 10 12]]


















